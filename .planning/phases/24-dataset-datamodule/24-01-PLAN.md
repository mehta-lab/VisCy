---
phase: 24-dataset-datamodule
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - applications/dynaclr/src/dynaclr/dataset.py
  - applications/dynaclr/tests/test_dataset.py
autonomous: true

must_haves:
  truths:
    - "MultiExperimentTripletDataset.__getitems__ returns a dict with 'anchor' and 'positive' keys as Tensors of shape (B, C, Z, Y, X) compatible with ContrastiveModule.training_step"
    - "Positive sampling follows lineage through division events -- when an anchor track ends at a division, the daughter track at t+tau is selected as a valid positive"
    - "Each anchor's positive is sampled from the same lineage_id at t+tau using exponential decay via sample_tau"
    - "Patch extraction uses tensorstore for efficient I/O with per-experiment channel_map index remapping"
  artifacts:
    - path: "applications/dynaclr/src/dynaclr/dataset.py"
      provides: "MultiExperimentTripletDataset class"
      exports: ["MultiExperimentTripletDataset"]
    - path: "applications/dynaclr/tests/test_dataset.py"
      provides: "TDD tests for dataset"
      contains: "test_getitems_returns_anchor_positive"
  key_links:
    - from: "applications/dynaclr/src/dynaclr/dataset.py"
      to: "dynaclr.index.MultiExperimentIndex"
      via: "uses index.valid_anchors DataFrame for anchor lookup and index.tracks for positive search"
      pattern: "self\\.index\\.valid_anchors"
    - from: "applications/dynaclr/src/dynaclr/dataset.py"
      to: "dynaclr.tau_sampling.sample_tau"
      via: "samples temporal offset for positive selection"
      pattern: "sample_tau"
    - from: "applications/dynaclr/src/dynaclr/dataset.py"
      to: "dynaclr.experiment.ExperimentRegistry"
      via: "uses registry.channel_maps for per-experiment channel index remapping"
      pattern: "channel_maps"
---

<objective>
Implement MultiExperimentTripletDataset with __getitems__ that returns batch dicts compatible with ContrastiveModule.training_step, using lineage-aware positive sampling with variable tau.

Purpose: This is the core dataset that reads cell patches from multi-experiment zarr stores, samples temporal positives following lineage through division events, and produces the exact batch format the engine expects.

Output: `dataset.py` with MultiExperimentTripletDataset class and TDD test suite.
</objective>

<execution_context>
@/Users/eduardo.hirata/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eduardo.hirata/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key source files to understand interfaces
@applications/dynaclr/src/dynaclr/engine.py        # ContrastiveModule.training_step expects TripletSample: {"anchor": Tensor, "positive": Tensor}
@applications/dynaclr/src/dynaclr/index.py          # MultiExperimentIndex provides tracks, valid_anchors, registry
@applications/dynaclr/src/dynaclr/experiment.py      # ExperimentRegistry has channel_maps, tau_range_frames
@applications/dynaclr/src/dynaclr/tau_sampling.py    # sample_tau(tau_min, tau_max, rng, decay_rate) -> int
@packages/viscy-data/src/viscy_data/triplet.py       # Existing TripletDataset pattern to follow (tensorstore, __getitems__)
@packages/viscy-data/src/viscy_data/_typing.py        # TripletSample TypedDict, NormMeta type
@packages/viscy-data/src/viscy_data/_utils.py         # _read_norm_meta helper
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD -- MultiExperimentTripletDataset with lineage-aware positive sampling</name>
  <files>
    applications/dynaclr/src/dynaclr/dataset.py
    applications/dynaclr/tests/test_dataset.py
  </files>
  <action>
**RED phase -- Write failing tests first in `test_dataset.py`:**

Create a test file with synthetic data fixtures (no real zarr needed for unit tests). Use a mock/synthetic approach:

1. **Fixture: `synthetic_index`** -- Create a mock MultiExperimentIndex-like object with:
   - A `valid_anchors` DataFrame with columns: experiment, condition, global_track_id, lineage_id, t, y, x, y_clamp, x_clamp, fov_name, position, fluorescence_channel
   - At least 2 experiments with different channel_maps
   - Include a division event: track A has parent producing daughter tracks B and C (same lineage_id)
   - A `registry` with ExperimentRegistry providing channel_maps and tau_range_frames
   - A `tracks` DataFrame (superset of valid_anchors with additional timepoints for positive lookup)

2. **Test cases** (minimum 6 tests):
   - `test_getitems_returns_anchor_positive_keys`: Call `__getitems__([0, 1])` and assert result has "anchor" and "positive" keys, both Tensors of shape `(2, num_channels, z_depth, yx, yx)`
   - `test_getitems_returns_norm_meta`: Assert result has "anchor_norm_meta" key (list of NormMeta or None)
   - `test_positive_same_lineage`: For an anchor at (lineage_id=L, t=T), verify the positive comes from the same lineage_id at t=T+tau (where tau > 0)
   - `test_positive_through_division`: Create anchor on parent track that divides. Verify positive is sampled from daughter track at t+tau (same lineage_id, different global_track_id)
   - `test_channel_remapping`: With 2 experiments having different channel orderings but same source_channel count, verify patches are extracted with correct channel indices per experiment
   - `test_predict_mode_returns_index`: With `fit=False`, verify result has "index" key with TrackingIndex-compatible dicts

For the tests that need actual I/O, mock the tensorstore reads or use a tiny in-memory zarr. The simplest approach: patch `_get_tensorstore` to return a numpy array wrapped in a mock that supports `.oindex[...]` slicing.

**GREEN phase -- Implement `dataset.py`:**

```python
class MultiExperimentTripletDataset(Dataset):
    """Dataset for multi-experiment triplet sampling with lineage-aware positives.

    Works with MultiExperimentIndex to sample anchor/positive cell patches
    across multiple experiments, following lineage through division events.
    """

    def __init__(
        self,
        index: MultiExperimentIndex,
        fit: bool = True,
        tau_range_hours: tuple[float, float] = (0.5, 2.0),
        tau_decay_rate: float = 2.0,
        return_negative: bool = False,
        cache_pool_bytes: int = 0,
    ) -> None:
```

Key implementation details:

1. **`__init__`**: Store `index` (MultiExperimentIndex), extract `registry`, `valid_anchors`, `tracks`. Set up tensorstore context (same pattern as existing TripletDataset._setup_tensorstore_context). Build a lookup structure: `_lineage_timepoints` dict mapping `(experiment, lineage_id)` -> dict of `{t: list[row_indices_in_tracks]}` for O(1) positive lookup.

2. **`__len__`**: Return `len(self.index.valid_anchors)`.

3. **`__getitems__(self, indices: list[int]) -> dict`**: This is the batched getter (same pattern as existing TripletDataset.__getitems__):
   - Look up anchor rows from `self.index.valid_anchors.iloc[indices]`
   - For each anchor, sample tau via `sample_tau(tau_min, tau_max, rng, decay_rate)` where tau_min/tau_max come from `registry.tau_range_frames(exp_name, tau_range_hours)`
   - Find positive: look up rows in `self.index.tracks` matching `(lineage_id, t + tau)` -- this naturally follows lineage through divisions since daughter tracks share lineage_id
   - Extract patches for anchors and positives using tensorstore with per-experiment `channel_maps` remapping (source position 0 -> zarr index from channel_map)
   - Return `{"anchor": anchor_tensor, "positive": positive_tensor, "anchor_norm_meta": [...], "positive_norm_meta": [...]}`
   - In predict mode (`fit=False`): return `{"anchor": anchor_tensor, "index": [TrackingIndex dicts]}`

4. **`_get_tensorstore`**: Cache tensorstore objects keyed by `(experiment, fov_name)`. Same pattern as existing TripletDataset._get_tensorstore.

5. **`_slice_patch`**: Given a track row and experiment name, extract `(t, [channel_indices], z_range, y_slice, x_slice)` where channel_indices come from `self.index.registry.channel_maps[exp_name]` -- maps source position to zarr index. Use `y_clamp` and `x_clamp` (border-clamped) for patch centering.

6. **`_find_positive`**: Given anchor row, tau: look up `(lineage_id, anchor_t + tau)` in the pre-built lineage-timepoint index. If multiple candidates exist (e.g., both parent and daughter at same t+tau), pick one randomly. If no candidate at sampled tau, try other taus in range (fallback). This guarantees lineage-linked positive selection.

7. **RNG**: Use `numpy.random.default_rng()` (no fixed seed in dataset -- sampler handles determinism). Each `__getitems__` call creates a local RNG or uses a shared one.

**IMPORTANT**: The batch dict keys must match what `ContrastiveModule.training_step` reads:
- `batch["anchor"]` -> Tensor (B, C, Z, Y, X)
- `batch["positive"]` -> Tensor (B, C, Z, Y, X)
- Optional: `batch["anchor_norm_meta"]`, `batch["positive_norm_meta"]` (used by on_after_batch_transfer, not by engine)

The dataset does NOT need to return `batch["negative"]` because NTXentLoss uses in-batch negatives. `return_negative=False` by default.

**REFACTOR phase**: Clean up, add docstrings, ensure type hints are complete.
  </action>
  <verify>
Run: `cd /Users/eduardo.hirata/Documents/repos/VisCy && uv run --package dynaclr pytest applications/dynaclr/tests/test_dataset.py -v`

All tests pass. Verify at least 6 test cases exist and pass.
  </verify>
  <done>
MultiExperimentTripletDataset.__getitems__ returns batch dicts with anchor/positive Tensors compatible with ContrastiveModule.training_step. Positive sampling uses lineage_id for same-track AND daughter-track matching at t+tau. Channel remapping uses per-experiment channel_maps. At least 6 TDD tests pass.
  </done>
</task>

</tasks>

<verification>
1. `uv run --package dynaclr pytest applications/dynaclr/tests/test_dataset.py -v` -- all tests pass
2. `uv run --package dynaclr python -c "from dynaclr.dataset import MultiExperimentTripletDataset; print('OK')"` -- import works
3. Verify `__getitems__` returns dict with keys matching TripletSample: anchor (Tensor), positive (Tensor)
4. Verify positive selection follows lineage through division events (test_positive_through_division passes)
</verification>

<success_criteria>
- MultiExperimentTripletDataset is implemented with __getitems__ returning ContrastiveModule-compatible batch dicts
- Lineage-aware positive sampling is tested including division events
- Channel remapping per experiment is verified
- All TDD tests pass (RED -> GREEN -> REFACTOR complete)
</success_criteria>

<output>
After completion, create `.planning/phases/24-dataset-datamodule/24-01-SUMMARY.md`
</output>

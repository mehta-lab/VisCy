---
phase: 10-public-api-ci-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/viscy-models/src/viscy_models/__init__.py
  - packages/viscy-models/tests/test_state_dict_compat.py
  - .github/workflows/test.yml
autonomous: true

must_haves:
  truths:
    - "from viscy_models import UNeXt2, FullyConvolutionalMAE, ContrastiveEncoder, ResNet3dEncoder, BetaVae25D, BetaVaeMonai, Unet2d, Unet25d succeeds without error"
    - "uv run --package viscy-models pytest passes all tests including new compatibility tests"
    - "CI workflow runs viscy-models tests alongside viscy-transforms tests"
    - "State dict keys for all 8 models match their original monolithic counterparts exactly"
    - "Root pyproject.toml already lists viscy-models as workspace dependency (no change needed)"
  artifacts:
    - path: "packages/viscy-models/src/viscy_models/__init__.py"
      provides: "Top-level re-exports of all 8 model classes"
      contains: "__all__"
    - path: "packages/viscy-models/tests/test_state_dict_compat.py"
      provides: "State dict key compatibility regression tests for all 8 models"
      contains: "state_dict"
    - path: ".github/workflows/test.yml"
      provides: "CI test matrix including viscy-models"
      contains: "viscy-models"
  key_links:
    - from: "packages/viscy-models/src/viscy_models/__init__.py"
      to: "packages/viscy-models/src/viscy_models/unet/__init__.py"
      via: "re-export imports"
      pattern: "from viscy_models\\.unet import"
    - from: "packages/viscy-models/src/viscy_models/__init__.py"
      to: "packages/viscy-models/src/viscy_models/contrastive/__init__.py"
      via: "re-export imports"
      pattern: "from viscy_models\\.contrastive import"
    - from: "packages/viscy-models/src/viscy_models/__init__.py"
      to: "packages/viscy-models/src/viscy_models/vae/__init__.py"
      via: "re-export imports"
      pattern: "from viscy_models\\.vae import"
    - from: ".github/workflows/test.yml"
      to: "packages/viscy-models"
      via: "CI test job working-directory"
      pattern: "viscy-models"
---

<objective>
Wire the public API for viscy-models (top-level imports for all 8 models), add state dict compatibility regression tests, and update CI to test viscy-models alongside viscy-transforms.

Purpose: This is the final phase -- it ensures users can `from viscy_models import ModelName` for all 8 architectures, that checkpoint compatibility is regression-tested, and that CI validates the full package on every PR.

Output: Updated __init__.py with re-exports, new state dict compatibility test file, updated CI workflow.
</objective>

<execution_context>
@/Users/eduardo.hirata/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eduardo.hirata/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/viscy-models/src/viscy_models/__init__.py
@packages/viscy-models/src/viscy_models/unet/__init__.py
@packages/viscy-models/src/viscy_models/contrastive/__init__.py
@packages/viscy-models/src/viscy_models/vae/__init__.py
@packages/viscy-models/tests/conftest.py
@.github/workflows/test.yml
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add top-level re-exports for all 8 model classes</name>
  <files>packages/viscy-models/src/viscy_models/__init__.py</files>
  <action>
Update `packages/viscy-models/src/viscy_models/__init__.py` to re-export all 8 model classes from their subpackage __init__.py files. The file currently only has `__version__` and an empty `__all__`.

Add imports from each subpackage:
- `from viscy_models.unet import UNeXt2, FullyConvolutionalMAE, Unet2d, Unet25d`
- `from viscy_models.contrastive import ContrastiveEncoder, ResNet3dEncoder`
- `from viscy_models.vae import BetaVae25D, BetaVaeMonai`

Update `__all__` to list all 8 classes in alphabetical order:
```python
__all__ = [
    "BetaVae25D",
    "BetaVaeMonai",
    "ContrastiveEncoder",
    "FullyConvolutionalMAE",
    "ResNet3dEncoder",
    "UNeXt2",
    "Unet2d",
    "Unet25d",
]
```

Keep the existing `__version__` line. Keep the module docstring. Place imports after `__version__`.

Note: The ruff config (`pyproject.toml` line 68) already suppresses D104 (missing docstring in public package) and F401 (imported but unused) for `__init__.py` files, so these re-exports will pass linting.
  </action>
  <verify>
Run `python -c "from viscy_models import UNeXt2, FullyConvolutionalMAE, ContrastiveEncoder, ResNet3dEncoder, BetaVae25D, BetaVaeMonai, Unet2d, Unet25d; print('All 8 models importable')"` from the repo root using `uv run --package viscy-models`. Should print success message.

Also verify `python -c "import viscy_models; print(viscy_models.__all__)"` shows all 8 classes.
  </verify>
  <done>All 8 model classes are importable via `from viscy_models import ModelName` and listed in `__all__`.</done>
</task>

<task type="auto">
  <name>Task 2: Add state dict key compatibility regression tests</name>
  <files>packages/viscy-models/tests/test_state_dict_compat.py</files>
  <action>
Create `packages/viscy-models/tests/test_state_dict_compat.py` to regression-test that state dict keys for all 8 migrated models match their original monolithic counterparts exactly (requirement COMPAT-01).

The test strategy: instantiate each model with default/minimal parameters, call `model.state_dict().keys()`, and verify against a frozen reference set of keys. This catches any accidental renaming of attributes, use of `nn.ModuleList` vs `register_module`, or structural changes that would break checkpoint loading.

For each model, write a test function that:
1. Instantiates the model with specific (small/fast) config
2. Gets `sorted(model.state_dict().keys())`
3. Asserts equality against a frozen reference list

Use these configurations for fast tests (avoid large backbones):
- `UNeXt2(backbone="convnextv2_atto")` -- smallest ConvNeXt backbone
- `FullyConvolutionalMAE(backbone="convnextv2_atto")` -- smallest ConvNeXt backbone
- `ContrastiveEncoder(backbone="convnext_tiny", in_channels=1, in_stack_depth=5, stem_kernel_size=(5, 4, 4))` -- convnext_tiny is the default
- `ResNet3dEncoder(in_channels=1)` -- uses MONAI ResNet, no timm
- `BetaVae25D(in_channels=1, out_channels=1, input_shape=(5, 64, 64))` -- minimal config. Uses default backbone="resnet50"
- `BetaVaeMonai(in_channels=1, out_channels=1, latent_dim=128, spatial_dims=2, input_shape=(64, 64))` -- 2D variant, smaller
- `Unet2d(in_channels=1, out_channels=1)` -- default config
- `Unet25d(in_channels=1, out_channels=1)` -- default config

To generate the reference key sets: first write the tests WITH the model instantiation and a temporary `print(sorted(model.state_dict().keys()))` to capture the actual keys. Then freeze those as the reference. Or more practically: instantiate each model, capture keys, and assert they match a known reference.

Since the reference keys are the current (correct) state and this is a regression test, the approach is:
1. Instantiate model
2. Get keys
3. Check specific structural properties that would break if state dict changed:
   - Total number of keys (catches added/removed parameters)
   - Presence of critical top-level prefixes (e.g., "stem.", "decoder.", "encoder.", "head.")
   - A sample of specific key names from different parts of the model

For each model, assert:
- `len(state_dict)` equals expected count
- A set of "sentinel keys" (5-10 keys from different parts of the model hierarchy) are all present
- No unexpected top-level prefixes appear

This approach is more maintainable than freezing thousands of keys while still catching structural regressions.

Use the `device` fixture from conftest.py. All models should be instantiated on CPU (no `.to(device)` needed since we only check keys, not forward pass).

Add docstring: "State dict key compatibility tests ensuring migrated models preserve checkpoint-loadable structure."

Import all models from top-level: `from viscy_models import UNeXt2, ...` (also tests Task 1).
  </action>
  <verify>
Run `cd /Users/eduardo.hirata/Documents/repos/VisCy/packages/viscy-models && uv run --package viscy-models pytest tests/test_state_dict_compat.py -v`. All 8 tests should pass.
  </verify>
  <done>State dict compatibility regression tests exist for all 8 models, verifying parameter count and sentinel key presence. Tests pass and would catch any structural changes that break checkpoint loading.</done>
</task>

<task type="auto">
  <name>Task 3: Add viscy-models to CI test matrix</name>
  <files>.github/workflows/test.yml</files>
  <action>
Update `.github/workflows/test.yml` to run viscy-models tests alongside viscy-transforms tests.

The current workflow has a single `test` job that runs viscy-transforms only. Refactor to use a matrix strategy that tests both packages.

Add a `package` dimension to the matrix:
```yaml
matrix:
  os: [ubuntu-latest, macos-latest, windows-latest]
  python-version: ["3.11", "3.12", "3.13"]
  package: [viscy-transforms, viscy-models]
```

Update the job name to include the package:
```yaml
name: Test (${{ matrix.package }}, Python ${{ matrix.python-version }}, ${{ matrix.os }})
```

Update the `Install dependencies` step to use `matrix.package`:
```yaml
- name: Install dependencies
  run: uv sync --frozen --all-extras --dev
  working-directory: packages/${{ matrix.package }}
```

Update the `Run tests with coverage` step to dynamically determine the coverage source. The import name differs from the package name (viscy-transforms -> viscy_transforms, viscy-models -> viscy_models). Use shell substitution to convert the hyphen:
```yaml
- name: Run tests with coverage
  run: |
    COV_PKG=$(echo "${{ matrix.package }}" | tr '-' '_')
    uv run --frozen pytest --cov=$COV_PKG --cov-report=term-missing
  working-directory: packages/${{ matrix.package }}
```

Note: On Windows, the `tr` command may not be available. Use a different approach that works cross-platform. Instead, use an `env` variable or matrix include. The simplest cross-platform approach: add a `cov-package` to the matrix via `include` or just use the package name directly since pytest-cov can accept the package directory path.

Actually, the simplest cross-platform approach: use `--cov=src/` instead of a named package. This avoids the hyphen-to-underscore issue entirely and works on all platforms:
```yaml
- name: Run tests with coverage
  run: uv run --frozen pytest --cov=src/ --cov-report=term-missing
  working-directory: packages/${{ matrix.package }}
```

This works because both packages use the `src/` layout and `--cov=src/` will measure coverage for whatever is under `src/`.

The `check` job already aggregates all test jobs via `alls-green`, so it will automatically include the new viscy-models test jobs. No changes needed to the `check` job.

The total matrix will be 3 OS x 3 Python x 2 packages = 18 jobs (up from 9).
  </action>
  <verify>
Validate the YAML syntax: `python -c "import yaml; yaml.safe_load(open('.github/workflows/test.yml'))"` (or just verify the file is valid YAML). Also visually inspect the matrix dimensions are correct.

Note: The actual CI will run on push/PR to main. For local verification, just confirm the YAML is syntactically valid and the matrix is correctly structured.
  </verify>
  <done>CI test workflow includes viscy-models in the test matrix alongside viscy-transforms. Matrix produces 18 jobs (3 OS x 3 Python x 2 packages). The `check` gate job automatically aggregates all test results.</done>
</task>

</tasks>

<verification>
1. Run full test suite from the viscy-models package directory:
   ```bash
   cd /Users/eduardo.hirata/Documents/repos/VisCy/packages/viscy-models && uv run --package viscy-models pytest -v
   ```
   All tests must pass (existing 69 + new state dict compat tests).

2. Verify top-level imports work:
   ```bash
   uv run --package viscy-models python -c "from viscy_models import UNeXt2, FullyConvolutionalMAE, ContrastiveEncoder, ResNet3dEncoder, BetaVae25D, BetaVaeMonai, Unet2d, Unet25d; print('OK')"
   ```

3. Verify root pyproject.toml already has viscy-models (no change needed -- API-04):
   ```bash
   grep "viscy-models" pyproject.toml
   ```

4. Validate CI YAML:
   ```bash
   python -c "import yaml; yaml.safe_load(open('.github/workflows/test.yml')); print('Valid YAML')"
   ```
</verification>

<success_criteria>
- All 8 model classes importable from `viscy_models` top-level package
- State dict key compatibility tests pass for all 8 models
- CI workflow matrix includes both viscy-transforms and viscy-models (18 jobs)
- Root pyproject.toml already lists viscy-models (verified, no change needed)
- Full test suite passes: existing 69 tests + new compatibility tests
</success_criteria>

<output>
After completion, create `.planning/phases/10-public-api-ci-integration/10-01-SUMMARY.md`
</output>

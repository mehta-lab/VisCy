---
phase: 21-cell-index-lineage
plan: 02
type: tdd
wave: 2
depends_on: ["21-01"]
files_modified:
  - applications/dynaclr/src/dynaclr/index.py
  - applications/dynaclr/tests/test_index.py
  - applications/dynaclr/src/dynaclr/__init__.py
autonomous: true

must_haves:
  truths:
    - "valid_anchors is a subset of tracks where each anchor has at least one tau in the configured range that yields a same-track or daughter-track (same lineage_id) positive"
    - "Variable tau range accounts for per-experiment frame rates -- tau_range_hours is converted to frames per experiment via registry.tau_range_frames"
    - "experiment_groups property returns dict mapping experiment names to arrays of row indices in tracks"
    - "condition_groups property returns dict mapping condition labels to arrays of row indices in tracks"
    - "summary() returns a human-readable string with experiment counts, track counts, and anchor counts"
    - "MultiExperimentIndex is importable from dynaclr top-level package"
  artifacts:
    - path: "applications/dynaclr/src/dynaclr/index.py"
      provides: "MultiExperimentIndex with valid_anchors, properties, summary"
      min_lines: 200
    - path: "applications/dynaclr/tests/test_index.py"
      provides: "Tests for valid_anchors, experiment_groups, condition_groups, summary"
      min_lines: 250
    - path: "applications/dynaclr/src/dynaclr/__init__.py"
      provides: "Top-level export of MultiExperimentIndex"
      contains: "MultiExperimentIndex"
  key_links:
    - from: "applications/dynaclr/src/dynaclr/index.py"
      to: "dynaclr.experiment.ExperimentRegistry.tau_range_frames"
      via: "method call for tau conversion"
      pattern: "tau_range_frames"
    - from: "applications/dynaclr/src/dynaclr/__init__.py"
      to: "applications/dynaclr/src/dynaclr/index.py"
      via: "re-export"
      pattern: "from dynaclr\\.index import MultiExperimentIndex"
---

<objective>
TDD: Valid anchor computation with variable tau range and lineage continuity, plus properties, summary, and package wiring (CELL-04).

Purpose: Complete the MultiExperimentIndex by adding the valid_anchors filter that determines which cells can serve as training anchors. An anchor is valid only if it has at least one temporal positive (same-track or daughter-track within lineage) at any tau in the configured range. This is critical for the contrastive sampling pipeline -- invalid anchors would produce pairs without meaningful temporal signal.

Output: Updated `index.py` with valid_anchors computation + properties, updated `test_index.py` with anchor tests, updated `__init__.py` with top-level export.
</objective>

<execution_context>
@/Users/eduardo.hirata/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eduardo.hirata/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-cell-index-lineage/21-01-SUMMARY.md
@applications/dynaclr/src/dynaclr/index.py
@applications/dynaclr/src/dynaclr/experiment.py
</context>

<feature>
  <name>Valid anchor computation with variable tau and lineage continuity</name>
  <files>applications/dynaclr/src/dynaclr/index.py, applications/dynaclr/tests/test_index.py, applications/dynaclr/src/dynaclr/__init__.py</files>

  <behavior>
    **CELL-04: Valid anchors with variable tau range and lineage continuity**

    MultiExperimentIndex.__init__ now also takes tau_range_hours: tuple[float, float] parameter.

    After building self.tracks (from Plan 01), compute self.valid_anchors:

    1. For each experiment, convert tau_range_hours to frames using registry.tau_range_frames(exp.name, tau_range_hours) -> (min_frames, max_frames)
    2. For each row in tracks belonging to that experiment:
       - For each tau in range(min_frames, max_frames + 1):
         - Check if there exists another row with the SAME lineage_id and t == anchor_t + tau
         - "Same lineage_id" means: same-track OR daughter-track (they share the lineage root)
       - If ANY tau yields a valid positive -> row is a valid anchor
    3. self.valid_anchors = tracks[valid_mask].reset_index(drop=True)

    Key insight: Using lineage_id (from Plan 01) makes this simple. Two cells share a lineage_id if they are on the same track or are parent/daughter. So the check is just: "is there a row with same lineage_id at t + tau?"

    Efficient implementation approach:
    - Group tracks by (experiment, lineage_id)
    - For each group, get the set of timepoints
    - For each row in the group, check if any t+tau (for tau in frame range) is in the timepoint set
    - This avoids O(n^2) pairwise comparisons

    Test cases (for a 10-timepoint experiment with 30min interval, tau_range_hours=(0.5, 1.5)):
    - tau_range_frames = (1, 3) at 30min intervals
    - Track at t=0 with observations at t=0,1,2,...,9 -> valid (t=0+1=1 exists)
    - Track at t=9 -> NOT valid (t=9+1=10, t=9+2=11, t=9+3=12 all outside data)
    - Track at t=7 -> valid (t=7+1=8 exists)
    - Track at t=8 -> valid (t=8+1=9 exists)
    - Daughter track starting at t=5 with parent ending at t=4 -> parent at t=3 is valid IF daughter has observation at t=3+tau for some tau in range (they share lineage_id, so daughter's t=5 would satisfy tau=2 from parent's t=3)
    - Track with gap (missing t=3) -> t=2 with tau_range (1,3): check t=3 (missing), t=4 (exists), t=5 (exists) -> still valid because t=4 exists
    - Empty tracks -> empty valid_anchors
    - Different experiments with different intervals -> each uses its own tau_range_frames conversion

    For experiment with 15min interval and tau_range_hours=(0.5, 1.5):
    - tau_range_frames = (2, 6)
    - Track at t=0 -> needs at least one of t=2,3,4,5,6 in same lineage -> valid if t=2+ exists

    **Properties:**

    experiment_groups -> dict[str, np.ndarray]:
      Groups tracks.index by "experiment" column. Returns {exp_name: array_of_row_indices}.

    condition_groups -> dict[str, np.ndarray]:
      Groups tracks.index by "condition" column. Returns {condition_label: array_of_row_indices}.

    **summary() -> str:**
      Returns multi-line string:
      ```
      MultiExperimentIndex: {N} experiments, {M} total observations, {K} valid anchors
        exp_a: {n1} observations, {k1} anchors, conditions: uninfected(50), infected(30)
        exp_b: {n2} observations, {k2} anchors, conditions: control(40)
      ```
  </behavior>

  <implementation>
    Updates to applications/dynaclr/src/dynaclr/index.py:

    1. Add tau_range_hours parameter to __init__:
       ```python
       def __init__(
           self,
           registry: ExperimentRegistry,
           z_range: slice,
           yx_patch_size: tuple[int, int],
           tau_range_hours: tuple[float, float] = (0.5, 2.0),
           include_wells: list[str] | None = None,
           exclude_fovs: list[str] | None = None,
       ) -> None:
       ```

    2. After self.tracks = tracks.reset_index(drop=True), call:
       ```python
       self.valid_anchors = self._compute_valid_anchors(tau_range_hours)
       ```

    3. Implement _compute_valid_anchors:
       ```python
       def _compute_valid_anchors(self, tau_range_hours):
           if self.tracks.empty:
               return self.tracks.copy()

           valid_mask = pd.Series(False, index=self.tracks.index)

           for exp in self.registry.experiments:
               min_f, max_f = self.registry.tau_range_frames(exp.name, tau_range_hours)
               exp_mask = self.tracks["experiment"] == exp.name
               exp_tracks = self.tracks[exp_mask]

               # Build set of (lineage_id, t) pairs for fast lookup
               lineage_timepoints = set(zip(exp_tracks["lineage_id"], exp_tracks["t"]))

               for idx, row in exp_tracks.iterrows():
                   for tau in range(min_f, max_f + 1):
                       if tau == 0:
                           continue  # anchor cannot be its own positive
                       if (row["lineage_id"], row["t"] + tau) in lineage_timepoints:
                           valid_mask[idx] = True
                           break

           return self.tracks[valid_mask].reset_index(drop=True)
       ```

    4. Implement properties:
       ```python
       @property
       def experiment_groups(self) -> dict[str, np.ndarray]:
           return {name: group.index.to_numpy() for name, group in self.tracks.groupby("experiment")}

       @property
       def condition_groups(self) -> dict[str, np.ndarray]:
           return {name: group.index.to_numpy() for name, group in self.tracks.groupby("condition")}

       def summary(self) -> str:
           lines = [f"MultiExperimentIndex: {len(self.registry.experiments)} experiments, "
                    f"{len(self.tracks)} total observations, {len(self.valid_anchors)} valid anchors"]
           for exp in self.registry.experiments:
               exp_tracks = self.tracks[self.tracks["experiment"] == exp.name]
               exp_anchors = self.valid_anchors[self.valid_anchors["experiment"] == exp.name]
               cond_counts = exp_tracks.groupby("condition").size()
               cond_str = ", ".join(f"{c}({n})" for c, n in cond_counts.items())
               lines.append(f"  {exp.name}: {len(exp_tracks)} observations, "
                            f"{len(exp_anchors)} anchors, conditions: {cond_str}")
           return "\n".join(lines)
       ```

    5. Update __init__.py to export MultiExperimentIndex:
       ```python
       from dynaclr.index import MultiExperimentIndex
       # Add to __all__
       ```

    Test fixtures: Reuse fixtures from Plan 01 (already in test_index.py). Add new test class TestValidAnchors with tests for:
    - Basic anchor validity (track with enough future timepoints -> valid)
    - Track ending near max_t -> not valid
    - Lineage continuity (parent valid because daughter has future timepoints in same lineage)
    - Different tau ranges for different experiment intervals
    - Empty tracks -> empty valid_anchors
    - experiment_groups returns correct index arrays
    - condition_groups returns correct index arrays
    - summary() returns non-empty string with correct experiment count

    Also add TestMultiExperimentIndexProperties class for experiment_groups, condition_groups, summary.
  </implementation>
</feature>

<verification>
- `cd /Users/eduardo.hirata/Documents/repos/VisCy && uv run --package dynaclr pytest applications/dynaclr/tests/test_index.py -v` -- all tests pass (including Plan 01 tests)
- `uv run --package dynaclr python -c "from dynaclr import MultiExperimentIndex; print('OK')"` -- top-level import works
- `uv run --package dynaclr python -c "from dynaclr.index import MultiExperimentIndex; print(MultiExperimentIndex.__init__.__doc__)"` -- docstring present
- valid_anchors is a strict subset of tracks (len(valid_anchors) <= len(tracks))
- valid_anchors contains no rows where all tau values miss (verified by test)
</verification>

<success_criteria>
- valid_anchors correctly identifies anchors with at least one valid tau yielding a same-lineage positive
- Variable tau range uses per-experiment frame conversion via registry.tau_range_frames
- Lineage continuity allows daughter tracks to satisfy parent anchor validity
- experiment_groups and condition_groups return correct index arrays
- summary() provides human-readable overview
- MultiExperimentIndex is importable from top-level dynaclr package
- All tests pass with TDD RED->GREEN->REFACTOR cycle
</success_criteria>

<output>
After completion, create `.planning/phases/21-cell-index-lineage/21-02-SUMMARY.md`
</output>

---
phase: 20-experiment-configuration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - applications/dynaclr/src/dynaclr/experiment.py
  - applications/dynaclr/tests/test_experiment.py
autonomous: true

must_haves:
  truths:
    - "ExperimentConfig can be instantiated with name, data_path, tracks_path, channel_names, source_channel, condition_wells and all fields are accessible"
    - "ExperimentRegistry validates that all experiments have the same number of source_channel entries"
    - "ExperimentRegistry raises ValueError if any source_channel entry is not in its experiment's channel_names"
    - "ExperimentRegistry computes channel_maps mapping each experiment's source_channel indices to zarr channel indices"
    - "ExperimentRegistry.from_yaml loads experiments from a YAML file and returns a valid registry"
    - "ExperimentRegistry.tau_range_frames converts hours to frames using per-experiment interval_minutes"
    - "ExperimentRegistry raises ValueError if zarr metadata channel_names do not match ExperimentConfig.channel_names"
  artifacts:
    - path: "applications/dynaclr/src/dynaclr/experiment.py"
      provides: "ExperimentConfig and ExperimentRegistry dataclasses"
      exports: ["ExperimentConfig", "ExperimentRegistry"]
      min_lines: 120
    - path: "applications/dynaclr/tests/test_experiment.py"
      provides: "Comprehensive tests for experiment configuration"
      min_lines: 150
  key_links:
    - from: "applications/dynaclr/tests/test_experiment.py"
      to: "applications/dynaclr/src/dynaclr/experiment.py"
      via: "from dynaclr.experiment import ExperimentConfig, ExperimentRegistry"
      pattern: "from dynaclr\\.experiment import"
    - from: "applications/dynaclr/src/dynaclr/experiment.py"
      to: "iohub.ngff"
      via: "open_ome_zarr for zarr channel validation"
      pattern: "from iohub\\.ngff import open_ome_zarr"
    - from: "applications/dynaclr/src/dynaclr/experiment.py"
      to: "yaml"
      via: "yaml.safe_load for from_yaml classmethod"
      pattern: "import yaml"
---

<objective>
Implement ExperimentConfig and ExperimentRegistry dataclasses with full validation, YAML loading, and tau-range conversion using TDD.

Purpose: Enable users to define multi-experiment training setups with automatic channel resolution and validation, which downstream phases (21-25) depend on for cell indexing, batch sampling, and dataset construction.

Output: `experiment.py` source module and `test_experiment.py` with comprehensive coverage of all 4 success criteria.
</objective>

<execution_context>
@/Users/eduardo.hirata/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eduardo.hirata/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-experiment-configuration/20-CONTEXT.md
@applications/dynaclr/pyproject.toml
@applications/dynaclr/src/dynaclr/__init__.py
@applications/dynaclr/tests/conftest.py
@packages/viscy-utils/src/viscy_utils/cli_utils.py
</context>

<feature>
  <name>ExperimentConfig and ExperimentRegistry with TDD</name>
  <files>
    applications/dynaclr/src/dynaclr/experiment.py
    applications/dynaclr/tests/test_experiment.py
  </files>
  <behavior>
    ExperimentConfig is a Python dataclass with these fields:
      - name: str (required, unique identifier)
      - data_path: str (required, path to HCS OME-Zarr)
      - tracks_path: str (required, root dir for per-FOV tracking CSVs)
      - channel_names: list[str] (required, all channels in zarr store)
      - source_channel: list[str] (required, which channels to use for training)
      - condition_wells: dict[str, list[str]] (required, condition_label -> well names)
      - interval_minutes: float = 30.0
      - start_hpi: float = 0.0 (hours post infection at frame 0)
      - organelle: str = ""
      - date: str = ""
      - moi: float = 0.0

    ExperimentRegistry is a dataclass wrapping list[ExperimentConfig] with:
      - experiments: list[ExperimentConfig]
      - num_source_channels: int (validated: same count across all experiments)
      - channel_maps: dict[str, dict[int, int]] (experiment_name -> {source_idx: zarr_idx})

    Validation rules (all at __post_init__, fail-fast):
      1. Duplicate experiment names -> ValueError
      2. Empty experiments list -> ValueError
      3. For each experiment: source_channel entries must be in channel_names -> ValueError with specifics
      4. All experiments must have same len(source_channel) -> ValueError showing counts
      5. data_path must exist as directory -> ValueError
      6. Open zarr briefly with iohub, read channel names from first position, compare to channel_names -> ValueError with diff if mismatch
      7. Additional: negative interval_minutes -> ValueError, empty condition_wells -> ValueError

    channel_maps computation:
      For experiment with channel_names=["Phase", "GFP", "RFP"] and source_channel=["Phase", "RFP"]:
        channel_maps["exp_name"] = {0: 0, 1: 2}
        (source position 0 -> zarr index 0, source position 1 -> zarr index 2)

    from_yaml(path: str | Path) -> ExperimentRegistry:
      Reads YAML like:
        experiments:
          - name: "exp_a"
            data_path: "/path/to/exp_a.zarr"
            tracks_path: "/path/to/exp_a/tracks"
            channel_names: ["Phase", "GFP", "Mito"]
            source_channel: ["Phase", "GFP"]
            condition_wells:
              uninfected: ["A/1", "A/2"]
              infected: ["B/1", "B/2"]
            interval_minutes: 30.0
            start_hpi: 3.0

    tau_range_frames(experiment_name: str, tau_range_hours: tuple[float, float]) -> tuple[int, int]:
      Converts hours to frames: frame = round(hours * 60 / interval_minutes)
      Example: tau_range_hours=(0.5, 2.0), interval_minutes=30 -> (1, 4)
      Example: tau_range_hours=(0.5, 2.0), interval_minutes=15 -> (2, 8)
      Warns (logging.warning) if result yields fewer than 2 valid frames (i.e., min_frames >= max_frames)

    get_experiment(name: str) -> ExperimentConfig:
      Returns the config by name, raises KeyError if not found.

    Test cases (RED phase):
      1. test_experiment_config_creation -- all fields accessible
      2. test_experiment_config_defaults -- default values for optional fields
      3. test_registry_channel_maps -- correct source->zarr index mapping
      4. test_registry_channel_maps_different_names -- positional alignment with different channel names across experiments
      5. test_registry_source_channel_not_in_channel_names -- ValueError
      6. test_registry_mismatched_source_channel_count -- ValueError
      7. test_registry_duplicate_names -- ValueError
      8. test_registry_empty_experiments -- ValueError
      9. test_registry_zarr_validation -- opens zarr, validates channel_names match
      10. test_registry_zarr_channel_mismatch -- ValueError with diff
      11. test_registry_data_path_not_exists -- ValueError
      12. test_from_yaml -- round-trip: write YAML, load, verify registry
      13. test_tau_range_frames_30min -- (0.5, 2.0) at 30min -> (1, 4)
      14. test_tau_range_frames_15min -- (0.5, 2.0) at 15min -> (2, 8)
      15. test_tau_range_frames_warns_few_frames -- warns when min >= max
      16. test_get_experiment -- lookup by name
      17. test_get_experiment_not_found -- KeyError
      18. test_negative_interval_minutes -- ValueError
      19. test_empty_condition_wells -- ValueError
  </behavior>
  <implementation>
    RED phase:
      Create test_experiment.py with all 19 test cases. Tests import from dynaclr.experiment.
      For zarr validation tests: create real mini zarr stores using iohub fixtures (tmp_path + open_ome_zarr with layout="hcs").
      Create a session-scoped conftest fixture or use tmp_path directly in tests.
      For from_yaml test: write YAML to tmp_path, load it back.
      Run: uv run --package dynaclr pytest applications/dynaclr/tests/test_experiment.py -- ALL MUST FAIL (ImportError since module does not exist yet).
      Commit: test(20-01): add failing tests for ExperimentConfig and ExperimentRegistry

    GREEN phase:
      Create experiment.py with ExperimentConfig and ExperimentRegistry.
      Use @dataclass for both (project pattern, not pydantic -- per user decision that project uses dataclass pattern).
      ExperimentConfig: plain dataclass, no __post_init__ (validation at registry level).
      ExperimentRegistry.__post_init__:
        1. Check experiments not empty
        2. Check no duplicate names (build name->config dict)
        3. For each experiment: validate source_channel subset of channel_names
        4. Validate all experiments have same len(source_channel) -> set num_source_channels
        5. Compute channel_maps: for each experiment, {i: channel_names.index(sc) for i, sc in enumerate(source_channel)}
        6. For each experiment: validate data_path exists (Path(data_path).exists())
        7. For each experiment: open zarr with open_ome_zarr, read channel names from first position, compare to channel_names
        8. Additional: negative interval_minutes, empty condition_wells checks on each config
      from_yaml: classmethod, uses yaml.safe_load, constructs ExperimentConfig list, returns cls(experiments=configs)
      tau_range_frames: lookup experiment by name, compute frame = round(hours * 60 / interval_minutes), warn if min >= max
      get_experiment: dict lookup by name

      For zarr channel name reading: use iohub pattern:
        with open_ome_zarr(data_path, mode="r") as plate:
            first_position = next(iter(plate.positions()))[1]
            zarr_channels = list(first_position.channel_names)

      Run: uv run --package dynaclr pytest applications/dynaclr/tests/test_experiment.py -- ALL MUST PASS.
      Commit: feat(20-01): implement ExperimentConfig and ExperimentRegistry

    REFACTOR phase (if needed):
      Clean up docstrings, improve error messages, ensure consistent style with existing dynaclr modules.
      Run tests again to confirm still passing.
      Commit: refactor(20-01): clean up experiment module
  </implementation>
</feature>

<verification>
All tests pass: `uv run --package dynaclr pytest applications/dynaclr/tests/test_experiment.py -v`
Module is importable: `uv run --package dynaclr python -c "from dynaclr.experiment import ExperimentConfig, ExperimentRegistry; print('OK')"`
</verification>

<success_criteria>
1. ExperimentConfig instantiation with all fields works and fields are accessible (SC-1)
2. ExperimentRegistry validates channel count consistency and computes channel_maps (SC-2, modified per CONTEXT.md -- no shared/all modes)
3. ExperimentRegistry validates source_channel membership in channel_names (SC-2/3 modified per CONTEXT.md)
4. from_yaml classmethod loads YAML into a valid ExperimentRegistry (SC-4)
5. tau_range_frames correctly converts hours to frames per experiment
6. All 19+ tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-experiment-configuration/20-01-SUMMARY.md`
</output>

"""Pydantic schemas for Airtable records and model registry."""

from typing import Any, Literal

from pydantic import BaseModel, Field, field_validator


class DatasetRecord(BaseModel):
    """
    Pydantic model for a dataset record (FOV) in Airtable.

    This represents a single field of view (FOV) from an HCS plate,
    with metadata about the biological sample and data location.

    Note
    ----
    FOV_ID is a computed field in Airtable (formula: Dataset + "_" + Well ID + "_" + FOV)
    and is automatically generated. You can read it but cannot set it during creation.
    """

    # Required fields for creation (but optional when reading from Airtable due to legacy data)
    dataset_name: str = Field(
        ...,
        description="Name of the dataset/plate this FOV belongs to",
        alias="Dataset",
    )
    well_id: str = Field(
        ...,
        description="Well identifier (e.g., 'B_3' or 'B/3')",
        alias="Well ID",
    )
    fov_name: str = Field(
        ..., description="FOV index within well (e.g., '0', '1', '2')", alias="FOV"
    )
    data_path: str | None = Field(
        None,
        description="Full path to FOV data (e.g., '/hpc/data/plate.zarr/B/3/0'). Required for new records.",
        alias="Data path",
    )

    # Computed field (read-only, auto-generated by Airtable)
    fov_id: str | None = Field(
        None,
        description="Computed FOV identifier (Dataset_WellID_FOV) - auto-generated by Airtable",
        alias="FOV_ID",
        exclude=True,  # Don't include in to_airtable_dict() by default
    )

    # Optional metadata fields
    cell_type: str | None = Field(
        None, description="Cell type (e.g., 'RPE1', 'A549')", alias="Cell type"
    )
    cell_state: str | None = Field(
        None,
        description="Cell state (e.g., 'healthy', 'infected')",
        alias="Cell state",
    )
    cell_line: list[str] | None = Field(
        None,
        description="Cell line identifiers (Airtable array field)",
        alias="Cell line",
    )
    organelle: str | None = Field(
        None, description="Target organelle (e.g., 'SEC61B')", alias="Organelle"
    )
    channel_0: str | None = Field(
        None, description="Channel 0 name (e.g., 'Phase')", alias="Channel-0"
    )
    channel_1: str | None = Field(
        None, description="Channel 1 name (e.g., 'GFP')", alias="Channel-1"
    )
    channel_2: str | None = Field(
        None, description="Channel 2 name (e.g., 'RFP')", alias="Channel-2"
    )
    fluorescence_modality: str | None = Field(
        None,
        description="Fluorescence modality (e.g., 'confocal')",
        alias="Fluorescence modality",
    )
    organellebox_infectomics: bool | None = Field(
        None,
        description="Part of OrganelleBox Infectomics dataset",
        alias="OrganelleBox Infectomics",
    )

    # Airtable record ID (not used for creation, but for retrieval)
    record_id: str | None = Field(None, description="Airtable record ID", alias="id")

    model_config = {
        "populate_by_name": True,  # Allow both field name and alias
        "str_strip_whitespace": True,  # Strip whitespace from strings
    }

    @field_validator("dataset_name", "well_id", "fov_name")
    @classmethod
    def no_empty_strings(cls, v: str) -> str:
        """Ensure required string fields are not empty."""
        if not v or not v.strip():
            raise ValueError("Field cannot be empty")
        return v.strip()

    @field_validator("fov_id")
    @classmethod
    def validate_fov_id(cls, v: str | None) -> str | None:
        """Validate FOV ID if provided (it's computed, so usually None on creation)."""
        if v is not None and (not v or not v.strip()):
            raise ValueError("FOV ID cannot be empty string if provided")
        return v.strip() if v else None

    @field_validator("data_path")
    @classmethod
    def validate_data_path(cls, v: str | None) -> str | None:
        """Validate data path format if provided."""
        if v is None:
            return None
        if not v.strip():
            raise ValueError("Data path cannot be empty string")
        # Don't check if path exists - it might be on a different machine
        # Just ensure it's a reasonable path format
        if not v.startswith("/"):
            raise ValueError("Data path must be an absolute path (start with /)")
        return v.strip()

    def to_airtable_dict(self) -> dict[str, Any]:
        """
        Convert to Airtable-compatible dictionary.

        Returns
        -------
        dict
            Dictionary with Airtable field names (aliases), excluding None values
            and the record_id field.
        """
        # Use by_alias=True to get Airtable field names
        # exclude_none=True to skip optional fields that weren't set
        return self.model_dump(
            by_alias=True, exclude_none=True, exclude={"id", "record_id"}
        )

    @classmethod
    def from_airtable_record(cls, record: dict[str, Any]) -> "DatasetRecord":
        """
        Create DatasetRecord from Airtable API response.

        Parameters
        ----------
        record : dict
            Airtable record with 'id' and 'fields' keys

        Returns
        -------
        DatasetRecord
            Parsed dataset record
        """
        return cls(id=record["id"], **record["fields"])

    def __str__(self) -> str:
        """Human-readable string representation."""
        identifier = (
            self.fov_id or f"{self.dataset_name}_{self.well_id}_{self.fov_name}"
        )
        path_str = self.data_path or "no path"
        return f"Dataset({identifier} @ {path_str})"

    def __repr__(self) -> str:
        """Detailed string representation."""
        return (
            f"DatasetRecord(dataset_name={self.dataset_name!r}, well_id={self.well_id!r}, "
            f"fov_name={self.fov_name!r}, fov_id={self.fov_id!r})"
        )


class ModelRecord(BaseModel):
    """
    Pydantic model for a registered model artifact.

    This represents a registered model in WandB with metadata about
    training, architecture, and file locations.
    """

    # Core identification
    model_name: str = Field(..., description="Model identifier")
    model_type: Literal["contrastive", "segmentation", "vae", "translation"] = Field(
        ..., description="Model category"
    )
    version: str = Field(..., description="Version (e.g., 'v1', 'v2')")

    # File locations
    checkpoint_path: str = Field(..., description="Absolute path to .ckpt file")
    config_artifact_path: str | None = Field(
        None, description="Path to downloaded config_fit.yml from artifact"
    )

    # Architecture (for quick reference)
    architecture: str | None = Field(
        None, description="Model architecture (e.g., '2.5D')"
    )
    backbone: str | None = Field(None, description="Backbone (e.g., 'convnext_tiny')")

    # Training lineage
    collection_name: str | None = Field(None, description="Training data collection")
    wandb_run_id: str | None = Field(None, description="Training run ID")
    wandb_artifact_url: str | None = Field(None, description="WandB artifact URL")

    # Metadata
    description: str | None = Field(None, description="Model description")
    trained_date: str | None = Field(None, description="Training date")

    model_config = {
        "populate_by_name": True,
        "str_strip_whitespace": True,
    }

    @field_validator("checkpoint_path")
    @classmethod
    def validate_checkpoint_path(cls, v: str) -> str:
        """Validate checkpoint path."""
        if not v.startswith("/"):
            raise ValueError("Checkpoint path must be absolute")
        if not v.endswith(".ckpt"):
            raise ValueError("Checkpoint must be .ckpt file")
        return v

    @field_validator("version")
    @classmethod
    def validate_version(cls, v: str) -> str:
        """Validate version format."""
        if not v or not v.strip():
            raise ValueError("Version cannot be empty")
        return v.strip()

    def to_wandb_metadata(self) -> dict[str, Any]:
        """
        Convert to WandB artifact metadata dictionary.

        Returns
        -------
        dict
            Dictionary suitable for wandb.Artifact(metadata=...)
        """
        return self.model_dump(
            exclude_none=True,
            exclude={"config_artifact_path"},  # Don't include temp paths
        )

    @classmethod
    def from_wandb_artifact(cls, artifact: Any) -> "ModelRecord":
        """
        Create ModelRecord from WandB artifact.

        Parameters
        ----------
        artifact : wandb.Artifact
            WandB artifact object

        Returns
        -------
        ModelRecord
            Parsed model record
        """
        metadata = artifact.metadata.copy()

        # Add artifact-level fields
        metadata["model_name"] = artifact.name
        if hasattr(artifact, "version"):
            metadata["version"] = artifact.version
        if hasattr(artifact, "description") and artifact.description:
            metadata["description"] = artifact.description
        if hasattr(artifact, "url"):
            metadata["wandb_artifact_url"] = artifact.url

        return cls(**metadata)

    def __str__(self) -> str:
        """Human-readable string representation."""
        return f"Model({self.model_name}:{self.version} @ {self.checkpoint_path})"

    def __repr__(self) -> str:
        """Detailed string representation."""
        return (
            f"ModelRecord(model_name={self.model_name!r}, model_type={self.model_type!r}, "
            f"version={self.version!r})"
        )
